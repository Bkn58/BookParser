package booksparser;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

import java.io.*;
import java.util.ArrayList;
import java.util.zip.*;

/**
 * @author bkn58
 * Программа распаковывает "на лету" zip-архив библиотеки книг,
 * проводит парсинг каждой xml-книги, 
 * выводит в таблицу автора, название, жанр, язык книги
 * Позволяет фильтрами по языку, жанру или автору выбрать нужное множество.
 * Выделив нужные строки в таблице курсором можно сохранить эти книги в заданном
 * каталоге в виде отдельных zip-файлов.
 * Программа предназначена для старых электронных устройств (электронных книг), 
 * которые не могут работать с большими файлами библиотек.
 */
public class JFBookParser extends javax.swing.JFrame {
    
    int cntFiles = 0;
    int nError = 0; // количество ошибочных файлов
    DefaultTableModel model;
    String  books [][]; // массив заголовков книг из zip-файла (файл, автор, жанр, название, язык, кодировка файла)
    /**
     * Creates new form JFBookParser
     */
    public JFBookParser() {
        initComponents();
        model = (DefaultTableModel) tDirs.getModel();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jFileChooser2 = new javax.swing.JFileChooser();
        tpOptions = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        pbInDir = new javax.swing.JButton();
        pbOutDir = new javax.swing.JButton();
        txtFolders = new javax.swing.JTextField();
        txtOutDir = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        tDirs = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        txtCntFiles = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        choiceGanre = new java.awt.Choice();
        jLabel3 = new javax.swing.JLabel();
        choiceLang = new java.awt.Choice();
        statusBar = new javax.swing.JTextField();
        progressBar = new javax.swing.JProgressBar();
        jLabel4 = new javax.swing.JLabel();
        txtAutor = new javax.swing.JTextField();
        pbFind = new javax.swing.JButton();
        pnOptions = new javax.swing.JPanel();
        lbBufLen = new javax.swing.JLabel();
        txBufLen = new javax.swing.JTextField();

        jFileChooser1.setApproveButtonToolTipText("");
        jFileChooser1.setCurrentDirectory(new java.io.File("E:\\Librusec\\Librusec\\Lib.Rus.Ec + MyHomeLib[FB2]\\lib.rus.ec"));
        jFileChooser1.setDialogTitle("");

        jFileChooser2.setDialogType(javax.swing.JFileChooser.SAVE_DIALOG);
        jFileChooser2.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        pbInDir.setText("InputFile");
        pbInDir.setToolTipText("");
        pbInDir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pbInDirActionPerformed(evt);
            }
        });

        pbOutDir.setText("Save To");
        pbOutDir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pbOutDirActionPerformed(evt);
            }
        });

        txtOutDir.setToolTipText("Каталог для сохранения можно редактировать");

        tDirs.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null},
                {null, null, null, null, null, null}
            },
            new String [] {
                "File", "Автор", "Жанр", "Название", "Язык", "Код"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tDirs.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        tDirs.setName("tDirs"); // NOI18N
        jScrollPane1.setViewportView(tDirs);

        jLabel1.setText("Прочитано файлов");

        txtCntFiles.setToolTipText("");

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel2.setText("Жанр");

        choiceGanre.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                choiceGanreItemStateChanged(evt);
            }
        });

        jLabel3.setText("Язык");
        jLabel3.setToolTipText("");

        choiceLang.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                choiceLangItemStateChanged(evt);
            }
        });

        statusBar.setToolTipText("");

        progressBar.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        progressBar.setStringPainted(true);

        jLabel4.setText("Автор");

        txtAutor.setText("*");
        txtAutor.setToolTipText("");

        pbFind.setText("Find");
        pbFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pbFindAutor(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(statusBar)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 342, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addComponent(jScrollPane1)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(txtCntFiles, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(30, 30, 30)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(choiceGanre, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(27, 27, 27)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(choiceLang, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(30, 30, 30)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(txtAutor, javax.swing.GroupLayout.DEFAULT_SIZE, 213, Short.MAX_VALUE))
                    .addComponent(txtFolders)
                    .addComponent(txtOutDir))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(pbFind, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pbOutDir, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pbInDir, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(20, 20, 20))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(pbInDir)
                    .addComponent(txtFolders, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(pbOutDir)
                    .addComponent(txtOutDir, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtCntFiles, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(jPanel1Layout.createSequentialGroup()
                                        .addGap(20, 20, 20)
                                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                                .addComponent(jLabel2)
                                                .addComponent(jLabel1))
                                            .addComponent(jLabel3)
                                            .addComponent(jLabel4))
                                        .addGap(11, 11, 11)))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(choiceLang, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(choiceGanre, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(pbFind)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtAutor, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 437, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(statusBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        tpOptions.addTab("Rename", jPanel1);

        lbBufLen.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        lbBufLen.setText("Длина буфера");

        txBufLen.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        txBufLen.setText("10000");
        txBufLen.setToolTipText("");

        javax.swing.GroupLayout pnOptionsLayout = new javax.swing.GroupLayout(pnOptions);
        pnOptions.setLayout(pnOptionsLayout);
        pnOptionsLayout.setHorizontalGroup(
            pnOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnOptionsLayout.createSequentialGroup()
                .addGap(42, 42, 42)
                .addComponent(lbBufLen, javax.swing.GroupLayout.PREFERRED_SIZE, 161, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(txBufLen, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(709, Short.MAX_VALUE))
        );
        pnOptionsLayout.setVerticalGroup(
            pnOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnOptionsLayout.createSequentialGroup()
                .addGap(34, 34, 34)
                .addGroup(pnOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(txBufLen, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lbBufLen))
                .addContainerGap(546, Short.MAX_VALUE))
        );

        tpOptions.addTab("Options", pnOptions);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tpOptions)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tpOptions)
        );

        tpOptions.getAccessibleContext().setAccessibleName("Options");

        pack();
    }// </editor-fold>//GEN-END:initComponents
/**
 * чтение исходного ZIP-файла 
 * @param evt 
 */
    private void pbInDirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pbInDirActionPerformed
        int returnVal = jFileChooser1.showOpenDialog(this);
        if (returnVal == jFileChooser1.APPROVE_OPTION) {
            File file = jFileChooser1.getSelectedFile();
            txtFolders.setText(file.getPath());
            cntFiles = 0;
            for (int i=model.getRowCount();i>0;i--) {
                model.removeRow(i-1);
            }
        if (!"".equals(txtFolders.getText())) {
            int ext_zip = file.getPath().lastIndexOf(".zip");
            String cat = file.getPath().substring(0, ext_zip);
            txtOutDir.setText(cat); //(txtFolders.getText());
          
            new java.lang.Thread(new Runnable() {
                public void run() {
                    statusBar.setText("ЖДИТЕ....");
//                        BuidTreeFolders (txtFolders.getText());
                    InputZip (file.getPath());                    // чтение напрямую из ZIP-файла
                    statusBar.setText("Готово. Ошибочных файлов:"+nError);
                }
            }).start();
        }
                
//                BuidTreeFolders (txtFolders.getText());
        } else {
        System.out.println("File access cancelled by user.");
        }
    }//GEN-LAST:event_pbInDirActionPerformed
/**
 * сохранение книг в заданном каталоге в виде отдельных zip-файлов
 * @param evt 
 */
    private void pbOutDirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pbOutDirActionPerformed
        File out_dir = new File (txtOutDir.getText());
//        jFileChooser2.setSelectedFile(out_dir);
//        jFileChooser2.setCurrentDirectory(out_dir);
//        int returnVal = jFileChooser2.showOpenDialog(this);
//        if (returnVal == jFileChooser2.APPROVE_OPTION) {
//            File file = jFileChooser2.getSelectedFile();

            out_dir.mkdir(); // создание каталога для сохраения файлов
            
//            txtOutDir.setText(file.getPath());
            cntFiles = 0;
        if (!"".equals(txtOutDir.getText())) {
            new java.lang.Thread(new Runnable() {
                public void run() {
                    try {
                        statusBar.setText("ЖДИТЕ....");
                        SaveZipToFolders (txtFolders.getText(),txtOutDir.getText());
//                        SaveToFolders (txtOutDir.getText());
                        
//                        txtStatus.setText("Готово.");
                    } catch (IOException ex) {
                        Logger.getLogger(JFBookParser.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }).start();
        }
                
//        } else {
//        System.out.println("Dir access cancelled by user.");
//        }
    }//GEN-LAST:event_pbOutDirActionPerformed

    private void choiceLangItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_choiceLangItemStateChanged
        
        int cnt_books = books.length;
        String lang = choiceLang. getSelectedItem();
        String ganre = choiceGanre.getSelectedItem(); 
        String b_lang;
    // очистка таблицы
        for (int i=model.getRowCount();i>0;i--) {
            model.removeRow(i-1);
        }
        // заполнение таблицы по выбранному языку с учетом выбранного жанра
        // (файл, автор, жанр, название, язык, кодировка файла)
        for (int i=0;i<cnt_books;i++){
            b_lang = books[i][4];
            if (b_lang != null)
            if ((lang.equals("*") || books[i][4].equals(lang))&&(ganre.equals("*") || books[i][2].equals(ganre))){
                Object[] newRow = new Object [] {books[i][0],books[i][1],books[i][2],books[i][3],books[i][4],books[i][5]};
                model.addRow (newRow);
 
            }
        }
        statusBar.setText("Выбрано файлов "+ model.getRowCount() + ".");
    }//GEN-LAST:event_choiceLangItemStateChanged

    private void choiceGanreItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_choiceGanreItemStateChanged
        // TODO add your handling code here:
        
        int cnt_books = books.length;
        String ganre = choiceGanre.getSelectedItem();
        String gbook;
        // очистка таблицы
        for (int i=model.getRowCount();i>0;i--) {
            model.removeRow(i-1);
        }
        // заполнение таблицы по выбранному жанру
        // (файл, автор, жанр, название, язык, кодировка файла)
        for (int i=0;i<cnt_books;i++){
            gbook= books[i][2]; 
            if (gbook != null)
            if (ganre.equals("*") || gbook.equalsIgnoreCase(ganre)){
                Object[] newRow = new Object [] {books[i][0],books[i][1],books[i][2],books[i][3],books[i][4],books[i][5]};
                model.addRow (newRow);
 
            }
        choiceLang.select("*"); // сброс фильтра языка
        statusBar.setText("Выбрано файлов "+ model.getRowCount() + ".");
        }
    }//GEN-LAST:event_choiceGanreItemStateChanged

/**
 * организует заполнение таблицы по автору
 * @param evt 
 */
    private void pbFindAutor(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pbFindAutor
        int cnt_books = books.length;
        String sAutor = txtAutor.getText().toUpperCase().trim();
        String bookAutor;
        // очистка таблицы
        for (int i=model.getRowCount();i>0;i--) {
            model.removeRow(i-1);
        }
        // заполнение таблицы по автору
        // (файл, автор, жанр, название, язык, кодировка файла)
        try 
        {
        for (int i=0;i<cnt_books;i++){
            //if (books[i][0].startsWith("144727"))
            bookAutor = books[i][1];
            if (bookAutor != null)
            if (sAutor.equals("*") || sAutor.equals("") || bookAutor.toUpperCase().trim().startsWith(sAutor)){
                Object[] newRow = new Object [] {books[i][0],books[i][1],books[i][2],books[i][3],books[i][4],books[i][5]};
                model.addRow (newRow);
 
            }
        }
        choiceLang.select("*"); // сброс фильтра языка
        choiceGanre.select("*");// сброс фильтра жанра
        statusBar.setText("Выбрано файлов "+ model.getRowCount() + ".");
        }
        catch(Exception ex){
            ex.printStackTrace();  
            System.out.println(ex.getMessage());
        } 
    }//GEN-LAST:event_pbFindAutor
    /**
     * Проверяет присутствие файла в таблице model
     * @param fname - имя файла
     * @return номер в таблице найденного файла или -1, если отсутствует в таблице
     */
    private int IsExistInTable (String fname){
        int cnt_books = model.getRowCount();
        for (int i =0; i<cnt_books; i++) {
                if (fname.equals((String)model.getValueAt(i, 0))) return i;  // номер в таблице найденного файла
            }
    return -1;    
    }
    /**
     * Проверяет выделение файла в таблице tDirs
     * @param row - номер строки в таблице
     * @return номер в таблице найденного файла или -1, если не выделен в таблице
     */
    private int IsRowSelectedInTable (int row){
            if (tDirs.isRowSelected(row))return row;  // номер в таблице найденного файла
            else return -1;    
    }

/**
 * сохраняет выбранные в таблице файлы в указанный каталог с предварительным сжатием каждого в отдельности в ZIP
 * @param sPath - исходный ZIP-файл
 * @param fld - каталог для сохраннения файлов
 * @throws IsExistInTable (проверяет наличие файла среди отфильтрованных в таблице) 
 */
    private void SaveZipToFolders (String sPath, String fld) throws IOException {
       int len = sPath.length();
       if (sPath.toUpperCase().endsWith(".ZIP")){ // проверяем - это zip?
       try(ZipInputStream zin = new ZipInputStream(new FileInputStream(sPath)))
        {   // читаем исходный ZIP-архив
            ZipEntry entry;
            String name;
            long size;
            int row, cnt=0; 
            int cntFile = model.getRowCount();
            
            progressBar.setMaximum(cntFile); // количество файлов в таблице
            
            while((entry=zin.getNextEntry())!=null){
                name = entry.getName(); // получим название очередного файла из ZIP-архива 
                size=entry.getSize();   // получим его размер в байтах
                
                // проверяем, входит ли данный файл в список для сохранения (есть ли данный файл в текущей таблице и выделен ли он)
                row = IsExistInTable (name);
                if ((row != -1) && (tDirs.isRowSelected(row))) {
                        // распаковка
                        byte [] inFile = new byte [(int)size];              // читаем весь XML-файл
                        int read = 0;
                        while (read < size) {
                            read += zin.read(inFile, read, (int)(size - read));
                        }
                        // записываем извлеченный файл в каталог с предварительной его упаковкой в ZIP-архив 
                        // формируем новое имя файла
                        String sOutPath = fld;
                        String filename, NameTmpFile;
                        sOutPath = sOutPath + "\\" +(String)model.getValueAt(row, 2);   // подкаталог жанр
                        sOutPath = sOutPath.trim();
                        filename = (String)model.getValueAt(row, 1);                    // автор
                        filename = filename + " "+ (String)model.getValueAt(row, 3);    // название
                        filename = filename.trim() + ".fb2";
//                        filename = filename.replaceAll("\\t\\f\\n\\r", "");
                        statusBar.setText(name + " " +sOutPath+ "\\" + filename);
                        
                        NameTmpFile = fld.trim() + "\\" + filename+".zip";     //  временно сохраняем в корне папки
                        try(ZipOutputStream zout = new ZipOutputStream(new FileOutputStream(NameTmpFile));)
                        {
                            ZipEntry entry1=new ZipEntry(filename);
                            zout.putNextEntry(entry1);
                            // добавляем содержимое к архиву
                            zout.write(inFile);
                            // закрываем текущую запись для новой записи
                            zout.closeEntry();
                            zout.close();
                            
                            String newFileName = sOutPath + "\\" + filename +".zip";
                            File tmpFile = new File (NameTmpFile);
                            File newFile = new File (sOutPath); 
                            // создаем каталог
                            newFile.mkdir();
                            // перемещаем в каталог по названию жанра
                            newFile = new File (newFileName);
                            tmpFile.renameTo(newFile);
                            
                            progressBar.setValue(++cnt);
                        }
                        catch(Exception ex){
                            System.out.println(ex.getMessage());
                            System.out.println (name + " " +sOutPath+ "\\" + filename);
                            ex.printStackTrace();
                        }  
                }        
                
            }
            zin.closeEntry();
            statusBar.setText ("Готово. Сохранено "+cntFile+ " файлов.");
       }
        catch(Exception ex){
            ex.printStackTrace();  
            System.out.println(ex.getMessage());
        } 
       }
}
/*
 устаревшее    
*/
    private void SaveToFolders (String fld) throws IOException {
        File pathName, oldName;
        String genre,autor, title, lang;
        for (int i=0;i<model.getRowCount();i++){
          lang = (String) model.getValueAt(i, 4);                // язык - только русский
           if(lang.equalsIgnoreCase("RU")||lang.equalsIgnoreCase("RUS")){  
            oldName = new File((String) model.getValueAt(i, 0)); // старое имя
            genre = (String) model.getValueAt(i, 2);             // жанр
            if (genre=="" || genre==null){
                genre = "Жанр неизвестен";
            }
            pathName = new File(fld+"\\"+genre);                 // каталог жанр
            pathName.mkdir();
            autor = (String) model.getValueAt(i, 1);             // автор
            if (autor == "" || autor == null){
                autor = "Автор неизвестен";
            }
            autor = autor.trim();
//            pathName = new File(fld+"\\"+genre+"\\"+autor);      // каталог автор
//            pathName.mkdir();
            title = (String) model.getValueAt(i, 3);
            if (title == "" || title == null){
                title = "Название неизвестно";
            }
            pathName = new File(fld+"\\"+genre+"\\"+autor+" "+title+".fb2");
            int cnt = 0;
            while (pathName.exists() && title == "Название неизвестно"){
                cnt++;
//                title = title + cnt;
                pathName = new File(fld+"\\"+genre+"\\"+autor+" "+title + cnt+".fb2");
            }
            if (oldName.renameTo(pathName)){
               txtCntFiles.setText(Integer.toString(i));
            }
            
        }
        }
    }
/**
  *  читает дерево каталогов и записывает все файлы в таблицу
*/    
    private void BuidTreeFolders (String fld) throws IOException {
      try
      {  
         File pathName = new File(fld);
         String[] fileNames = pathName.list();
         choiceLang.addItem("");
         choiceGanre.addItem("");
         // enumerate all files in the directory
         for (int i = 0; i < fileNames.length; i++)
         {  
            File f = new File(pathName.getPath(), fileNames[i]);
            if (!f.isDirectory()){
                Object[] newRow;
                newRow = new Object []
//                    {++cntFiles,f.getCanonicalPath(), null};
                    {f.getCanonicalPath(), null};
                model.addRow (newRow);
                txtCntFiles.setText(Integer.toString(++cntFiles));
                //ReadElements (f.getCanonicalPath(),cntFiles);     // парсинг "руками" структуры XML из предварительно распакованного ZIP файла
                //XMLReadElements (f.getCanonicalPath(),cntFiles);  // парсинг элементов из предварительно распакованного ZIP файла
                //StAXReadElements (f.getCanonicalPath(),cntFiles); // чтение предварительно распакованных из ZIP архива XML-файлов
                InputZip (f.getCanonicalPath());                    // чтение напрямую из ZIP-файла
            }

            // if the file is again a directory, call 
            // the main method recursively
            if (f.isDirectory())
            {  
               BuidTreeFolders(f.getPath());
            }
         }
      }
      catch(IOException e)
      {  
         e.printStackTrace(); 
      }
   }
    
/**
 * парсинг "на лету" элементов XML структуры из потока байтов ZIP-файла
 * @param src - поток байтов XML файла
 * @param row - номер строки в таблице model для отображения реквизитов книги
 */
    private boolean StAXReadElementsFromS (byte[] src, int row) {
    boolean bSucces=true;
    String name="", otch="", fam = "", autor="", genre="", title="", lang="", code="";
    Boolean bname=false, botch=false, bfam=false, bgenre=false, btitle=false, blang=false;
    int nError=0;
        try {

           ByteArrayInputStream byteStream = new ByteArrayInputStream(src);
           XMLStreamReader xmlr = XMLInputFactory.newInstance().createXMLStreamReader(byteStream);
           code = xmlr.getCharacterEncodingScheme();
            while (xmlr.hasNext()) {
                xmlr.next();
                if (xmlr.isStartElement()) {
                    if(xmlr.getLocalName().equals("first-name"))  bname=true;
                    if(xmlr.getLocalName().equals("middle-name")) botch=true;
                    if(xmlr.getLocalName().equals("last-name"))   bfam=true;
                    if(xmlr.getLocalName().equals("genre"))       bgenre=true;
                    if(xmlr.getLocalName().equals("book-title"))  btitle=true;
                    if(xmlr.getLocalName().equals("lang"))        blang=true;
                } else if (xmlr.isEndElement()) {
                    if (xmlr.getLocalName().equals("title-info")) {
                    autor = fam + " " + name + " " + otch;
//                    System.out.println(row + " " +autor + " "+genre+" "+title+" "+lang);
                    if (genre=="") genre = "unknow";
                    model.setValueAt(autor.replaceAll("[:/№,'\")(\\t\\f\\n\\r\\.\\?@]", ""), row, 1);
                    model.setValueAt(genre,row,2);
                    model.setValueAt(title.toUpperCase().replaceAll("[:/№,'\")(\\t\\f\\n\\r\\.\\?@]", ""), row, 3);
                    model.setValueAt(lang,  row, 4);
                    model.setValueAt(code,  row, 5);
                    int itemCount = choiceLang.getItemCount();
                    boolean isItemExist = false;
                    for (int i=0;i<itemCount;i++){
                        if (choiceLang.getItem(i).trim().equals(lang.trim())){
                            isItemExist=true;
                            break;
                        }
                    }
                    if (!isItemExist) {choiceLang.addItem(lang);}
                    
                    itemCount = choiceGanre.getItemCount();
                    isItemExist = false;
                    int pos=0; // позиция для вставки в список
                    for (int i=0;i<itemCount;i++){
                        int ins = choiceGanre.getItem(i).trim().compareTo(genre);
                        if (ins == 0) {isItemExist=true; break;} // такой элемент уже есть в списке
                        if (ins < 0)  {pos = i; break;}  // запоминаем позицию для вставки в список
                    }
                    if (!isItemExist) {choiceGanre.insert(genre,pos);}
                    //if (choiceGanre.getItem(pos)=="")choiceGanre.remove(pos);
                    break;
                    }
                } else if (xmlr.hasText()){ // && xmlr.getText().trim().length() > 0) {
                    if(bname)  {bname=false;  name=xmlr.getText();}
                    else if(botch)  {botch=false;  otch=xmlr.getText();}
                    else if(bfam)   {bfam=false;   fam=xmlr.getText();}
                    else if(bgenre) {
                        bgenre=false; 
                        genre=xmlr.getText().trim().replaceAll("[:/№,'\")(\\t\\f\\n\\r\\.\\?@]", "");
                        if (genre == " " || genre == "" || genre == null) genre = "unknow";
                        }
                    else if(btitle) {btitle=false; title=xmlr.getText();}
                    else if(blang)  {blang=false;  lang=xmlr.getText();}
                }
            }
        } catch (XMLStreamException ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
            bSucces = false;
        }
        return bSucces;
    }
/**
 парсинг элементов из предварительно распакованного ZIP файла (устаревшее)
*/
   private void StAXReadElements (String sPath, int row) {
    String name="", otch="", fam = "", autor="", genre="", title="", lang="", code="";
    Boolean bname=false, botch=false, bfam=false, bgenre=false, btitle=false, blang=false;
        try {
           XMLStreamReader xmlr = XMLInputFactory.newInstance().createXMLStreamReader(sPath, new FileInputStream(sPath));
           code = xmlr.getCharacterEncodingScheme();
            while (xmlr.hasNext()) {
                xmlr.next();
                if (xmlr.isStartElement()) {
                    if(xmlr.getLocalName()=="first-name")  bname=true;
                    if(xmlr.getLocalName()=="middle-name") botch=true;
                    if(xmlr.getLocalName()=="last-name")   bfam=true;
                    if(xmlr.getLocalName()=="genre")       bgenre=true;
                    if(xmlr.getLocalName()=="book-title")  btitle=true;
                    if(xmlr.getLocalName()=="lang")        blang=true;
                } else if (xmlr.isEndElement()) {
                    if (xmlr.getLocalName()=="title-info") {
                    autor = fam + " " + name + " " + otch;
                    model.setValueAt(autor.replaceAll("[:/№?,'\")(]", ""), row-1, 1);
                    model.setValueAt(genre, row-1, 2);
                    model.setValueAt(title.toUpperCase().replaceAll("[:/№?,'\")(]", ""), row-1, 3);
                    model.setValueAt(lang,  row-1, 4);
                    model.setValueAt(code,  row-1, 5);
                    break;
                    }
                } else if (xmlr.hasText() && xmlr.getText().trim().length() > 0) {
                    if(bname)  {bname=false;  name=xmlr.getText();}
                    if(botch)  {botch=false;  otch=xmlr.getText();}
                    if(bfam)   {bfam=false;   fam=xmlr.getText();}
                    if(bgenre) {bgenre=false; genre=xmlr.getText();}
                    if(btitle) {btitle=false; title=xmlr.getText();}
                    if(blang)  {blang=false;  lang=xmlr.getText();}
                }
            }
        } catch (FileNotFoundException | XMLStreamException ex) {
            ex.printStackTrace();
        }
    }
/**
 парсинг "руками" структуры XML (устаревшее)
*/    
   private void ReadElements (String sPath, int row) {
    String txtLine, first_name, genre, book_title;
    int beg,end;
    
       BufferedReader inputVar = null;
        try {
            File fin = new File(sPath);
            inputVar = Files.newBufferedReader(fin.toPath(), Charset.forName("Cp1251"));
                txtLine = inputVar.readLine();
                beg  = txtLine.indexOf("encoding=");
                end  = txtLine.indexOf("?>");
                if ((beg != -1)){
                  model.setValueAt(txtLine.substring(beg+9, end), row-1, 5); 
                }
                if (txtLine.contains("UTF-8")||txtLine.contains("utf-8")){
                  inputVar.close();
                  inputVar = Files.newBufferedReader(fin.toPath(), Charset.forName("UTF-8"));
                }
            // Читаем все строки файла
            int i = 0;
            String name="", otch="", fam = "", autor="";
            while (true)
            {
                txtLine = inputVar.readLine();
                if (txtLine==null) break;      // конец файла
                beg  = txtLine.indexOf("<first-name>");
                end  = txtLine.indexOf("</first-name>");
                if ((name=="")&&(beg != -1)&&(end != -1)){
                  name = txtLine.substring(beg+12, end); 
                }
                beg  = txtLine.indexOf("<middle-name>");
                end  = txtLine.indexOf("</middle-name>");
                if ((otch=="")&&(beg != -1)&&(end != -1)){
                  otch = txtLine.substring(beg+13, end); 
                }
                beg  = txtLine.indexOf("<last-name>");
                end  = txtLine.indexOf("</last-name>");
                if ((fam=="")&&(beg != -1)&&(end != -1)){
                  fam = txtLine.substring(beg+11, end); 
                }
                
                if ((fam == "")&&(name == "")&&(otch=="")){
                } else {
                    autor = fam + " " + name + " " + otch;
                    model.setValueAt(autor, row-1, 1);
                }
                beg  = txtLine.indexOf("<genre>");
                end  = txtLine.indexOf("</genre>");
                if ((beg != -1)&&(end != -1)){
                  model.setValueAt(txtLine.substring(beg+7, end), row-1, 2); 
                }
                beg  = txtLine.indexOf("<book-title>");
                end  = txtLine.indexOf("</book-title>");
                if ((beg != -1)&&(end != -1)){
                  model.setValueAt(txtLine.substring(beg+12, end), row-1, 3); 
                }
                beg  = txtLine.indexOf("<lang>");
                end  = txtLine.indexOf("</lang>");
                if ((beg != -1)&&(end != -1)){
                  model.setValueAt(txtLine.substring(beg+6, end), row-1, 4); 
                }
//                if (txtLine.matches(".*<p>.*</p>")){
                if (txtLine.matches("<body>")){
                  break; 
                }
            }
            inputVar.close();

        } catch (IOException ex) {
            Logger.getLogger(JFBookParser.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                inputVar.close();
            } catch (IOException ex) {
                Logger.getLogger(JFBookParser.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
   }

/**
 * распаковка ZIP файла напрямую в памяти и запись заголовков вложенных файлов в таблицу
 * @param sPath - путь к исходному ZIP файлу
 * @throws  StAXReadElementsFromS (чтение элементов книги из распакованного XML-файла и запись в таблицу model)
 */
   private void InputZip (String sPath)
   {
       int len = sPath.length();
       if (sPath.toUpperCase().endsWith(".ZIP")){ // проверяем - это zip?
       try(ZipInputStream zin = new ZipInputStream(new FileInputStream(sPath)))
        {
            choiceLang.addItem("*"); choiceLang.select("*");
            choiceGanre.addItem("*");choiceGanre.select("*");

            ZipEntry entry;
            String name;
            long size;
            int row=0; 
            while((entry=zin.getNextEntry())!=null){
                name = entry.getName(); // получим название файла
                size=entry.getSize();  // получим его размер в байтах
//                System.out.printf("%d \t File name: %s \t File size: %d \n", row, name, size);
                
                Object[] newRow;
                newRow = new Object [] {null,null};
                model.addRow (newRow);
                 
                // распаковка
                //int buf_len = Integer.parseInt(txBufLen.getText()); //из панели Options - мин длина начала XML-файла
                byte [] inFile = new byte [(int)size];              // читаем весь XML-файл
                int read = 0;
                while (read < size) {
                    read += zin.read(inFile, read, (int)(size - read));
                }

                model.setValueAt(name,  row, 0); // Записываем название файла в таблицу
                if (StAXReadElementsFromS (inFile, row)){ // чтение элементов книги из распакованного XML-файла
                    txtCntFiles.setText(Integer.toString(++cntFiles));
                }
                else {model.setValueAt("Ошибка распаковки !!!",  row, 1); nError++;}
                row = row + 1;  

                }
            zin.closeEntry();

            // запись всех полученных данных из таблицы в массив, который
            // используется для дальнейшего динамического заполнения таблицы по выбранным фильтрам
            int cnt_books = Integer.parseInt(txtCntFiles.getText());    // количество книг
            books = new String [cnt_books][6];                          // выделение памяти под данные
            for (int i =0; i<cnt_books; i++) {
                books[i][0] = (String)model.getValueAt(i, 0);           //файл
                books[i][1] = (String)model.getValueAt(i, 1);           //автор
                books[i][2] = (String)model.getValueAt(i, 2);           //жанр
                books[i][3] = (String)model.getValueAt(i, 3);           //название
                books[i][4] = (String)model.getValueAt(i, 4);           //язык
                books[i][5] = (String)model.getValueAt(i, 5);           //кодировка
            }
        }
        catch(Exception ex){
            ex.printStackTrace();  
            System.out.println(ex.getMessage());
        } 
       }
    } 
       
   
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
/*            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
*/            
            UIManager.setLookAndFeel(
                    UIManager.getSystemLookAndFeelClassName());

        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(JFBookParser.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(JFBookParser.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(JFBookParser.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(JFBookParser.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new JFBookParser().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Choice choiceGanre;
    private java.awt.Choice choiceLang;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JFileChooser jFileChooser2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lbBufLen;
    private javax.swing.JButton pbFind;
    private javax.swing.JButton pbInDir;
    private javax.swing.JButton pbOutDir;
    private javax.swing.JPanel pnOptions;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JTextField statusBar;
    private javax.swing.JTable tDirs;
    private javax.swing.JTabbedPane tpOptions;
    private javax.swing.JTextField txBufLen;
    private javax.swing.JTextField txtAutor;
    private javax.swing.JTextField txtCntFiles;
    private javax.swing.JTextField txtFolders;
    private javax.swing.JTextField txtOutDir;
    // End of variables declaration//GEN-END:variables
}
